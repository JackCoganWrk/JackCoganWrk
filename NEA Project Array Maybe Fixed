package io.github.some_example_name;
import com.badlogic.gdx.ApplicationAdapter;
import com.badlogic.gdx.ApplicationListener;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.ScreenUtils;
import javax.swing.*;
import java.util.Scanner;

/** {@link ApplicationListener} implementation shared by all platforms. */
public class Main extends ApplicationAdapter {
    ShapeRenderer sr;
    ShapeRenderer sr2;
    ShapeRenderer sr3;
    public Vector2 velocity;
    Scanner s = new Scanner(System.in);

    public Array<Person> peopleARRAY = new Array<>();
    public Array<Town> townARRAY = new Array<>();
    public Array<Transport> transportArray = new Array<>();
    float[] vertices = new float[8];
    private int screenWidth;
    private int screenHeight;
    float circleRadius = 3;
    float infectChance = 0.2f;
    float transportChance = 0.02f;
    float infectRoll;
    float transportRoll;

    @Override
    public void create() {
        int arrayTownSize = 0;
        int arrayPeopleSize = 0;

        try {

            System.out.println("ENTER PEOPLE NUMBER");
            arrayPeopleSize = s.nextInt();
            peopleARRAY = new Array<>(arrayPeopleSize);

            System.out.println("ENTER TOWN NUMBER");
            arrayTownSize = s.nextInt();
            townARRAY = new Array<>(arrayTownSize);

        } catch (Exception e) {

            System.out.println("ERROR DETECTED: INVALID INPUT");
            System.out.println("PLEASE RESET PROGRAM AND ENTER INTEGERS TO CONTINUE");
        }

        int j = 0;
        int h = 0;
        for (int i = 0; i <= arrayTownSize - 1; i++) {
            float town1x = 250 + j;
            float town1y = 250 + h;
            Town town = new Town(town1x, town1y, 30);
            townARRAY.add(town);
            j += 500;
            h += 50;
        }

        for (int f = 0; f <= arrayTownSize - 1; f++) {
            for (int d = 0; d <= arrayTownSize - 1; d++) {
                Town t1 = townARRAY.get(f);
                Town t2 = townARRAY.get(d);
                float vertex1X = t1.getTown1x();
                float vertex1Y = t1.getTown1y();
                float vertex2X = t1.getTown1x();
                float vertex2Y = t1.getTown1y();
                float vertex3X = t2.getTown1x();
                float vertex3Y = t2.getTown1y();
                float vertex4X = t2.getTown1x();
                float vertex4Y = t2.getTown1y();
                float[] vertices = {vertex1X, vertex1Y, vertex2X, vertex2Y, vertex3X, vertex3Y, vertex4X, vertex4Y};
                Transport transport = new Transport(vertices);
                transportArray.add(transport);
            }
        }

        for (int i = 0; i <= arrayPeopleSize - 1; i++) {
            float circleX = 100;//(float) Math.random() * 1010
            float circleY = 100;//(float) Math.random() * 1010
            Person person = new Person(circleX, circleY, circleRadius);
            peopleARRAY.add(person);
        }

        sr = new ShapeRenderer();
        sr2 = new ShapeRenderer();
        sr3 = new ShapeRenderer();
        velocity = new Vector2((float) Math.random() * 101 * 2, (float) Math.random() * 101 * 2);
        screenWidth = Gdx.graphics.getWidth();
        screenHeight = Gdx.graphics.getHeight();
    }

    @Override
    public void render() {

        //Get time
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
        ScreenUtils.clear(0.15f, 0.15f, 0.2f, 1f);
        float time = Gdx.graphics.getDeltaTime();

        for (Transport transport : transportArray) {
            transport.renderTransport(sr3);
        }

        for (Town town : townARRAY) {
            town.renderTown(sr2);
        }

        for (Person person : peopleARRAY) {
            person.renderShape(sr);
        }

        for (Person person : peopleARRAY) {
            person.setPersonPosition(person.circleX + person.velocity.x * time, person.circleY + person.velocity.y * time);

            if (person.circleX - circleRadius <= 0) {
                person.velocity.x *= -1;
                person.setPersonPosition(circleRadius, person.circleY);
            }

            if (person.circleX + circleRadius >= screenWidth) {
                person.velocity.x *= -1;
                person.setPersonPosition(screenWidth - circleRadius, person.circleY);
            }

            if (person.circleY - circleRadius <= 0) {
                person.velocity.y *= -1;
                person.setPersonPosition(person.circleX, circleRadius);
            }

            if (person.circleY + circleRadius >= screenHeight) {
                person.velocity.y *= -1;
                person.setPersonPosition(person.circleX, screenHeight - circleRadius);
            }
        }

        for (Person person : peopleARRAY) {
            for (Town town : townARRAY) {

                Vector2 circleDst = new Vector2(person.circleX, person.circleY);
                Vector2 townDst = new Vector2(town.getTown1x(), town.getTown1y());
                float distance = circleDst.dst(townDst);

                if (distance <= circleRadius + town.getTownRadius()) {

                    infectRoll = (float) Math.random();
                    person.velocity.x *= -1;
                    person.velocity.y *= -1;

                    if (infectRoll <= infectChance) {
                        person.green = 0f;
                        person.red = 1f;
                    }
                }
            }
        }

        for (int i = 0; i <= peopleARRAY.size - 1; i++) {
            for (int a = i + 1; a <= peopleARRAY.size - 1; a++) {
                Person p1 = peopleARRAY.get(i);
                Person p2 = peopleARRAY.get(a);
                Vector2 p1Dst = new Vector2(p1.circleX, p1.circleY);
                Vector2 p2dst = new Vector2(p2.circleX, p2.circleY);
                float distance = p1Dst.dst(p2dst);
                float willItCollide = (float) Math.random() * 101;

                if (willItCollide >= 20) {
                    if (distance <= circleRadius * 2) {
                        p1.velocity.x *= -1;
                        p1.velocity.y *= -1;
                        p2.velocity.x *= -1;
                        p2.velocity.y *= -1;

                        float infectRoll = (float) Math.random();
                        if (p1.red == 100f) {
                            if (infectRoll <= infectChance) {
                                p2.green = 0f;
                                p2.red = 100f;
                            }
                        }
                    }
                }
            }
        }

        for (Person person : peopleARRAY) {
            for (int i = 0; i < townARRAY.size; i++) {
                for (int f = 1; f < townARRAY.size; f++) {
                    if (i != f) {
                        Vector2 circleDst = new Vector2(person.circleX, person.circleY);
                        Vector2 townDst = new Vector2(townARRAY.get(i).getTown1x(), townARRAY.get(i).getTown1y());
                        float distance = circleDst.dst(townDst);

                        if (distance <= circleRadius + townARRAY.get(i).getTownRadius()) {
                            transportRoll = 0.8f;
                            if (transportChance <= transportRoll) {

                                float dx = townARRAY.get(f).getTown1x() - townARRAY.get(i).getTown1x();
                                float dy = townARRAY.get(f).getTown1y() - townARRAY.get(i).getTown1y();

                                //y = mx + c
                                //m = gradient

                                Vector2 scale = new Vector2(50, 50);
                                Vector2 transDst = new Vector2(dx, dy).nor().scl(scale);
                                // System.out.println(transDst.x + " " + transDst.y);
                                float dx2 = dx * dx;
                                float dy2 = dy * dy;
                                float dt2 = dx2 + dy2;
                                double sqrt = Math.sqrt(dt2);
                                float p = (float)sqrt;
                                person.setPersonPosition(townARRAY.get(i).getTown1x() + townARRAY.get(i).getTownRadius() + circleRadius + 2, townARRAY.get(i).getTown1y() + 5); //(townARRAY.size - 1).getTown1y() + dy);//townARRAY.get(townARRAY.size - 1).getTown1x() //(townARRAY.size - 1).getTown1y() + dy
                                System.out.println("dx = " + dx);
                                System.out.println("dy = " + dy);
                                person.velocity.x = transDst.x;
                                person.velocity.y = transDst.y;
                                //System.out.println("NEW POSITION = " + person.circleX + " " + person.circleY);
                                //System.out.println("NEW VELOCITY = " + person.velocity.x + " " + person.velocity.y);
                            }
                        }
                    }
                }
            }
        }
    }
}





package io.github.some_example_name;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
import com.badlogic.gdx.math.Vector2;

public class Person {


    // Parameters
    public Vector2 velocity = new Vector2((float) Math.random() * 101 * 2, (float) Math.random() * 101 * 2);
    public float circleX;
    public float circleY;
    private float circleRadius;

    float time = Gdx.graphics.getDeltaTime();
    //Set position
    public void setPosition(float personX, float personY) {
        this.personX = personX;
        this.personY = personY;
    }

    public void setPosition2(float personX2, float personY2) {
        this.personX2 = personX2;
        this.personY2 = personY2;
    }

    public void setPosition3(float personX3, float personY3) {
        this.personX3 = personX3;
        this.personY3 = personY3;
    }

    public void setPeopleArrayPosition(float v, float v1) {
        this.arrayX = arrayX;
        this.arrayY = arrayY;
    }

    public Person(float circleX, float circleY, float circleRadius) {
        this.circleX = circleX;
        this.circleY = circleY;
        this.circleRadius = circleRadius;
    }

    public void setPersonPosition(float circleX, float circleY) {
        this.circleX = circleX;
        this.circleY = circleY;
    }

    float red = 0f;
    float green = 100f;
    float blue = 0f;
    float a = 0f;

    public void renderShape(ShapeRenderer shapeRenderer) {
        shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);
        shapeRenderer.circle(circleX, circleY, circleRadius);
        shapeRenderer.setColor(red, green, blue, a);
        shapeRenderer.end();
    }

    int screenHeight = Gdx.graphics.getHeight();
    int screenWidth = Gdx.graphics.getWidth();
}




package io.github.some_example_name;

import com.badlogic.gdx.graphics.glutils.ShapeRenderer;

public class Town {
    private float townRadius = 30;

    public Town(float town1x, float town1y, float townRadius) {
        this.town1x = town1x;
        this.town1y = town1y;
        this.townRadius = getTownRadius();
    }


    public float getTownRadius (){
        return townRadius;
    }
    private float town1x;
    public float getTown1x (){
        return town1x;
    }
    private float town1y;
    public float getTown1y(){
        return town1y;
    }

    public void renderTown (ShapeRenderer shapeRenderer2){
        shapeRenderer2.begin(ShapeRenderer.ShapeType.Filled);
        shapeRenderer2.circle(getTown1x(), getTown1y(), getTownRadius());
        shapeRenderer2.setColor(100f, 100f,0f, 0f);
        shapeRenderer2.end();
    }
}

package io.github.some_example_name;

import com.badlogic.gdx.graphics.glutils.ShapeRenderer;

public class Transport {

    float vertex1X, vertex1Y, vertex2X, vertex2Y, vertex3X, vertex3Y, vertex4X, vertex4Y;
    public float[] vertices;

    public Transport (float [] vertices){
        this.vertices = vertices;
    }

    public void renderTransport (ShapeRenderer shapeRenderer3){
        shapeRenderer3.begin(ShapeRenderer.ShapeType.Line);
        shapeRenderer3.polygon(vertices);
        shapeRenderer3.setColor(50f, 50f, 50f, 0f);
        shapeRenderer3.end();
    }
}

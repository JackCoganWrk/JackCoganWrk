package io.github.some_example_name;
import com.badlogic.gdx.ApplicationAdapter;
import com.badlogic.gdx.ApplicationListener;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.ScreenUtils;
import java.util.Scanner;

/** {@link ApplicationListener} implementation shared by all platforms. */
public class Main extends ApplicationAdapter {
    ShapeRenderer sr;
    ShapeRenderer sr2;
    ShapeRenderer sr3;
    public Vector2 velocity;
    Scanner s = new Scanner(System.in);

    public Array<Person> peopleARRAY = new Array<>();
    public Array<Town> townARRAY = new Array<>();
    public Array<Transport> transportArray = new Array<>();
    private int screenWidth;
    private int screenHeight;
    float circleRadius = 3;
    float infectChance = 0.2f;
    float transportChance = 0.2f;
    float infectRoll;
    float transportRoll;
    float whichTransport;

    @Override
    public void create() {
        int arrayTownSize = 0;
        int arrayPeopleSize = 0;

        try {

            System.out.println("ENTER PEOPLE ARRAY SIZE");
            arrayPeopleSize = s.nextInt();
            peopleARRAY = new Array<>(arrayPeopleSize);

            System.out.println("ENTER TOWN ARRAY SIZE");
            arrayTownSize = s.nextInt();
            townARRAY = new Array<>(arrayTownSize);

        } catch (Exception e) {

            System.out.println("ERROR DETECTED: INVALID INPUT");
            System.out.println("PLEASE RESET PROGRAM AND ENTER AN INTEGER TO CONTINUE");

        }

        for (int i = 0; i <= arrayTownSize - 1; i++) {
            float town1x = (float) Math.random() * 1010;
            float town1y = (float) Math.random() * 1010;
            Town town = new Town(town1x, town1y, 30);
            townARRAY.add(town);
        }

        for (int f = 0; f <= arrayTownSize - 1; f++) {
            for (int d = 0; d <= arrayTownSize - 1; d++) {
                Town t1 = townARRAY.get(f);
                Town t2 = townARRAY.get(d);
                float vertex1X = t1.getTown1x();
                float vertex1Y = t1.getTown1y();
                float vertex2X = t1.getTown1x();
                float vertex2Y = t1.getTown1y();
                float vertex3X = t2.getTown1x();
                float vertex3Y = t2.getTown1y();
                float vertex4X = t2.getTown1x();
                float vertex4Y = t2.getTown1y();
                float[] vertices = {vertex1X, vertex1Y, vertex2X, vertex2Y, vertex3X, vertex3Y, vertex4X, vertex4Y};
                Transport transport = new Transport(vertices);
                transportArray.add(transport);
            }
        }

        for (int i = 0; i <= arrayPeopleSize - 1; i++) {
            float circleX = (float) Math.random() * 1010;
            float circleY = (float) Math.random() * 1010;
            Person person = new Person(circleX, circleY, circleRadius);
            peopleARRAY.add(person);
        }

        sr = new ShapeRenderer();
        sr2 = new ShapeRenderer();
        sr3 = new ShapeRenderer();
        velocity = new Vector2((float) Math.random() * 101 * 2, (float) Math.random() * 101 * 2);
        screenWidth = Gdx.graphics.getWidth();
        screenHeight = Gdx.graphics.getHeight();
    }

    @Override
    public void render() {

        //Get time
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
        ScreenUtils.clear(0.15f, 0.15f, 0.2f, 1f);
        float time = Gdx.graphics.getDeltaTime();

        for (Person person : peopleARRAY) {
            person.renderShape(sr);
        }

        for (Town town : townARRAY) {
            town.renderTown(sr2);
        }

        for (Transport transport : transportArray){
            transport.renderTransport(sr3);
        }

        for (Person person : peopleARRAY) {
            person.setPersonPosition(person.circleX + person.velocity.x * time, person.circleY + person.velocity.y * time);

            if (person.circleX - circleRadius <= 0) {
                person.velocity.x *= -1;
                person.setPersonPosition(circleRadius, person.circleY);
            }

            if (person.circleX + circleRadius >= screenWidth) {
                person.velocity.x *= -1;
                person.setPersonPosition(screenWidth - circleRadius, person.circleY);
            }

            if (person.circleY - circleRadius <= 0) {
                person.velocity.y *= -1;
                person.setPersonPosition(person.circleX, circleRadius);
            }

            if (person.circleY + circleRadius >= screenHeight) {
                person.velocity.y *= -1;
                person.setPersonPosition(person.circleX, screenHeight - circleRadius);
            }
        }

        for (Person person : peopleARRAY) {
            for (Town town : townARRAY) {
                Vector2 circleDst = new Vector2(person.circleX, person.circleY);
                Vector2 townDst = new Vector2(town.getTown1x(), town.getTown1y());
                float distance = circleDst.dst(townDst);

                if (distance <= circleRadius + town.getTownRadius()) {
                    infectRoll = (float) Math.random();
                    if (person.velocity.x > person.velocity.y) {
                        person.velocity.x *= -1;
                    }
                    if (person.velocity.y > person.velocity.x) {
                        person.velocity.y *= -1;
                    }
                    if (infectRoll <= infectChance) {
                        person.green = 0f;
                        person.red = 100f;
                    }

                    transportRoll = (float) Math.random();
                    if (transportRoll <= transportChance) {
                        whichTransport = (float)Math.random() * transportArray.size;
                        int whichTransportINT = (int) whichTransport;
                        Transport transport = transportArray.get(whichTransportINT);

                        person.velocity.x = transport.vertex3X - transport.vertex1X;
                        person.velocity.y = transport.vertex3Y - transport.vertex1Y;
                    }
                }
            }
        }

        for (int i = 0; i <= peopleARRAY.size - 1; i++) {
            for (int a = i + 1; a <= peopleARRAY.size - 1; a++) {
                Person p1 = peopleARRAY.get(i);
                Person p2 = peopleARRAY.get(a);
                Vector2 p1Dst = new Vector2(p1.circleX, p1.circleY);
                Vector2 p2dst = new Vector2(p2.circleX, p2.circleY);
                float distance = p1Dst.dst(p2dst);
                float willItCollide = (float) Math.random() * 101;

                if (willItCollide >= 20) {
                    if (distance <= circleRadius * 2) {
                        p1.velocity.x *= -1;
                        p1.velocity.y *= -1;
                        p2.velocity.x *= -1;
                        p2.velocity.y *= -1;

                        float infectRoll = (float)Math.random();
                        if (p1.red == 100f){
                            if (infectRoll <= infectChance){
                                p2.green = 0f;
                                p2.red = 100f;
                            }
                        }
                    }
                }
            }
        }
    }
}



package io.github.some_example_name;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
import com.badlogic.gdx.math.Vector2;

public class Person {


    // Parameters
    private float personX = (float) Math.random() * 101;
    private float personY = (float) Math.random() * 101;
    private float personX2 = 100;
    private float personY2 = 100;
    private float personX3 = 100;
    private float personY3 = 200;
    public float arrayX = 150;
    public float arrayY = 150;
    public Vector2 velocity = new Vector2((float) Math.random() * 101 * 2, (float) Math.random() * 101 * 2);
    public float circleX;
    public float circleY;
    private float circleRadius;


    //Getters
    public float getPersonX() {
        return personX;
    }
    public float getPersonY() {
        return personY;
    }
    public float getPersonX2() {
        return personX2;
    }
    public float getPersonY2() {
        return personY2;
    }
    public float getPersonX3() {
        return personX3;
    }
    public float getPersonY3() {
        return personY3;
    }
    public float getArrayX() {
        return arrayX;
    }
    public float getArrayY() {
        return arrayY;
    }

    float time = Gdx.graphics.getDeltaTime();
    //Set position
    public void setPosition(float personX, float personY) {
        this.personX = personX;
        this.personY = personY;
    }

    public void setPosition2(float personX2, float personY2) {
        this.personX2 = personX2;
        this.personY2 = personY2;
    }

    public void setPosition3(float personX3, float personY3) {
        this.personX3 = personX3;
        this.personY3 = personY3;
    }

    public void setPeopleArrayPosition(float v, float v1) {
        this.arrayX = arrayX;
        this.arrayY = arrayY;
    }

    public Person(float circleX, float circleY, float circleRadius) {
        this.circleX = circleX;
        this.circleY = circleY;
        this.circleRadius = circleRadius;
    }

    public void setPersonPosition(float circleX, float circleY) {
        this.circleX = circleX;
        this.circleY = circleY;
    }

    float red = 0f;
    float green = 100f;
    float blue = 0f;
    float a = 0f;

    public void renderShape(ShapeRenderer shapeRenderer) {
        shapeRenderer.begin(ShapeRenderer.ShapeType.Filled);
        shapeRenderer.circle(circleX, circleY, circleRadius);
        shapeRenderer.setColor(red, green, blue, a);
        shapeRenderer.end();
    }




    int screenHeight = Gdx.graphics.getHeight();
    int screenWidth = Gdx.graphics.getWidth();


    public void checkBoundary() {
        if (circleX - 6 <= 0) {
            setPersonPosition(100, circleY);
            velocity.x = velocity.x * -1;

        }
        if (circleX + 6 >= screenWidth) {
            setPersonPosition(screenWidth - 8, circleY);
            velocity.x = velocity.x * -1;
        }
        if (circleY - 6 <= 0) {
            setPersonPosition(circleX, 6);
            velocity.y = velocity.y * -1;
        }
        if (circleY + 6 >= screenHeight) {
            setPersonPosition(circleX, screenHeight - 6);
            velocity.y = velocity.y * -1;
        }
    }
}

package io.github.some_example_name;

import com.badlogic.gdx.graphics.glutils.ShapeRenderer;

public class Town {
    private float townRadius = 30;

    public Town(float town1x, float town1y, float townRadius) {
        this.town1x = town1x;
        this.town1y = town1y;
        this.townRadius = getTownRadius();
    }


    public float getTownRadius (){
        return townRadius;
    }
    private float town1x = (float) Math.random() * 1010;
    public float getTown1x (){
        return town1x;
    }
    private float town1y = (float) Math.random() * 1010;
    public float getTown1y(){
        return town1y;
    }

    public void renderTown (ShapeRenderer shapeRenderer2){
        shapeRenderer2.begin(ShapeRenderer.ShapeType.Filled);
        shapeRenderer2.circle(getTown1x(), getTown1y(), getTownRadius());
        shapeRenderer2.setColor(100f, 100f,0f, 0f);
        shapeRenderer2.end();
    }

    public void checkCollisionTown(){

    }
}

package io.github.some_example_name;

import com.badlogic.gdx.graphics.glutils.ShapeRenderer;

public class Transport {

    float vertex1X, vertex1Y, vertex2X, vertex2Y, vertex3X, vertex3Y, vertex4X, vertex4Y;
    public float[] vertices = {vertex1X, vertex1Y, vertex2X, vertex2Y, vertex3X, vertex3Y, vertex4X, vertex4Y};

    public Transport (float [] vertices){
        this.vertices = vertices;
    }

    public void renderTransport (ShapeRenderer shapeRenderer3){
        shapeRenderer3.begin(ShapeRenderer.ShapeType.Line);
        shapeRenderer3.polygon(vertices);
        shapeRenderer3.setColor(50f, 50f, 50f, 0f);
        shapeRenderer3.end();
    }
}
